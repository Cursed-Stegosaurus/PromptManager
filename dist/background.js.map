{
  "version": 3,
  "sources": ["../src/lib/db.ts", "../src/background/background.ts"],
  "sourcesContent": ["import type { LibraryState, Prompt } from \"./schema\";\r\n\r\nconst DB_NAME = \"prompt-library\";\r\nconst DB_VERSION = 1;\r\nconst STORE = \"prompts\";\r\nconst META = \"meta\";\r\n\r\nexport interface Meta {\r\n  key: string;\r\n  value: any;\r\n}\r\n\r\nexport async function openDb(): Promise<IDBDatabase> {\r\n  return await new Promise((resolve, reject) => {\r\n    const req = indexedDB.open(DB_NAME, DB_VERSION);\r\n    req.onupgradeneeded = () => {\r\n      const db = req.result;\r\n      if (!db.objectStoreNames.contains(STORE)) {\r\n        const s = db.createObjectStore(STORE, { keyPath: \"id\" });\r\n        s.createIndex(\"by_deletedAt\", \"deletedAt\", { unique: false });\r\n        s.createIndex(\"by_hidden\", \"hidden\", { unique: false });\r\n        s.createIndex(\"by_favorite\", \"favorite\", { unique: false });\r\n        s.createIndex(\"by_source\", \"source\", { unique: false });\r\n      }\r\n      if (!db.objectStoreNames.contains(META)) {\r\n        db.createObjectStore(META, { keyPath: \"key\" });\r\n      }\r\n    };\r\n    req.onsuccess = () => resolve(req.result);\r\n    req.onerror = () => reject(req.error);\r\n  });\r\n}\r\n\r\nexport async function putPrompt(p: Prompt) {\r\n  const db = await openDb();\r\n  await tx(db, STORE, \"readwrite\", store => store.put(p));\r\n}\r\n\r\nexport async function getPrompt(id: string): Promise<Prompt | undefined> {\r\n  const db = await openDb();\r\n  return await tx(db, STORE, \"readonly\", store => reqPromise<Prompt | undefined>(store.get(id)));\r\n}\r\n\r\nexport async function listPrompts(includeDeleted = false): Promise<Prompt[]> {\r\n  const db = await openDb();\r\n  return await tx(db, STORE, \"readonly\", store => new Promise((resolve, reject) => {\r\n    const out: Prompt[] = [];\r\n    const req = store.openCursor();\r\n    req.onsuccess = () => {\r\n      const cur = req.result as IDBCursorWithValue | null;\r\n      if (!cur) return resolve(out);\r\n      const val = cur.value as Prompt;\r\n      if (!val.deletedAt || includeDeleted) out.push(val);\r\n      cur.continue();\r\n    };\r\n    req.onerror = () => reject(req.error);\r\n  }));\r\n}\r\n\r\nexport async function putMeta(key: string, value: any) {\r\n  const db = await openDb();\r\n  await tx(db, META, \"readwrite\", store => store.put({ key, value }));\r\n}\r\n\r\nexport async function getMeta<T>(key: string): Promise<T | undefined> {\r\n  const db = await openDb();\r\n  return await tx(db, META, \"readonly\", store => reqPromise<T | undefined>(store.get(key)).then(r => r?.value));\r\n}\r\n\r\nexport async function deletePrompt(id: string) {\r\n  const db = await openDb();\r\n  const prompt = await getPrompt(id);\r\n  if (prompt) {\r\n    prompt.deletedAt = new Date().toISOString();\r\n    prompt.updatedAt = new Date().toISOString();\r\n    // Clear favorite flag when deleting\r\n    prompt.favorite = false;\r\n    await putPrompt(prompt);\r\n  }\r\n}\r\n\r\nexport async function restorePrompt(id: string) {\r\n  const db = await openDb();\r\n  const prompt = await getPrompt(id);\r\n  if (prompt && prompt.deletedAt) {\r\n    prompt.deletedAt = undefined;\r\n    prompt.updatedAt = new Date().toISOString();\r\n    await putPrompt(prompt);\r\n  }\r\n}\r\n\r\nexport async function toggleFavorite(id: string) {\r\n  const db = await openDb();\r\n  const prompt = await getPrompt(id);\r\n  if (prompt) {\r\n    prompt.favorite = !prompt.favorite;\r\n    prompt.updatedAt = new Date().toISOString();\r\n    await putPrompt(prompt);\r\n  }\r\n}\r\n\r\nexport async function toggleHidden(id: string) {\r\n  const db = await openDb();\r\n  const prompt = await getPrompt(id);\r\n  if (prompt) {\r\n    prompt.hidden = !prompt.hidden;\r\n    prompt.updatedAt = new Date().toISOString();\r\n    // Clear favorite flag when hiding (but not when unhiding)\r\n    if (prompt.hidden) {\r\n      prompt.favorite = false;\r\n    }\r\n    await putPrompt(prompt);\r\n  }\r\n}\r\n\r\nexport async function permanentlyDeletePrompt(id: string) {\r\n  const db = await openDb();\r\n  return await tx(db, STORE, \"readwrite\", store => {\r\n    return reqPromise(store.delete(id));\r\n  });\r\n}\r\n\r\nexport async function purgeDeletedPrompts(olderThanDays: number = 30) {\r\n  const db = await openDb();\r\n  const cutoff = new Date();\r\n  cutoff.setDate(cutoff.getDate() - olderThanDays);\r\n  \r\n  return await tx(db, STORE, \"readwrite\", store => new Promise((resolve, reject) => {\r\n    const req = store.openCursor();\r\n    const deletedIds: string[] = [];\r\n    \r\n    req.onsuccess = () => {\r\n      const cur = req.result as IDBCursorWithValue | null;\r\n      if (!cur) return resolve(deletedIds);\r\n      \r\n      const prompt = cur.value as Prompt;\r\n      if (prompt.deletedAt && new Date(prompt.deletedAt) < cutoff) {\r\n        deletedIds.push(prompt.id);\r\n        store.delete(prompt.id);\r\n      }\r\n      cur.continue();\r\n    };\r\n    req.onerror = () => reject(req.error);\r\n  }));\r\n}\r\n\r\nfunction tx<T>(db: IDBDatabase, name: string, mode: IDBTransactionMode, fn: (store: IDBObjectStore) => any): Promise<T> {\r\n  return new Promise((resolve, reject) => {\r\n    const t = db.transaction(name, mode);\r\n    const store = t.objectStore(name);\r\n    let result: any;\r\n    try { result = fn(store); } catch (e) { reject(e); return; }\r\n    t.oncomplete = () => resolve(result);\r\n    t.onerror = () => reject(t.error);\r\n    t.onabort = () => reject(t.error);\r\n  });\r\n}\r\n\r\nfunction reqPromise<T>(req: IDBRequest): Promise<T> {\r\n  return new Promise((resolve, reject) => {\r\n    req.onsuccess = () => resolve(req.result as T);\r\n    req.onerror = () => reject(req.error);\r\n  });\r\n}\r\n", "import { openDb, putPrompt, getMeta, putMeta } from '../lib/db.js';\r\nimport type { Prompt } from '../lib/schema.js';\r\n\r\n// Daily purge of recycle bin\r\nif (chrome.alarms) {\r\n  chrome.alarms.onAlarm.addListener(async (a) => {\r\n    if (a.name === \"purge\") {\r\n      await purgeRecycleBin();\r\n    }\r\n  });\r\n  \r\n  // Create daily purge alarm\r\n  chrome.alarms.create(\"purge\", { periodInMinutes: 24 * 60 });\r\n}\r\n\r\n// Ensure seeds are loaded when extension starts\r\nchrome.runtime.onStartup.addListener(async () => {\r\n  await ensureSeedLoaded();\r\n});\r\n\r\n// Handle extension installation and setup\r\nchrome.runtime.onInstalled.addListener(async () => {\r\n  await ensureSeedLoaded();\r\n  \r\n  // Create context menu for inserting prompts\r\n  chrome.contextMenus.create({\r\n    id: \"insert-prompt\",\r\n    title: \"Insert Prompt\",\r\n    contexts: [\"editable\"]\r\n  });\r\n});\r\n\r\n// Handle extension icon click to open sidebar\r\nchrome.action.onClicked.addListener(async (tab) => {\r\n  if (tab?.id) {\r\n    await chrome.sidePanel.open({ tabId: tab.id });\r\n  }\r\n});\r\n\r\nchrome.contextMenus.onClicked.addListener(async (info, tab) => {\r\n  if (info.menuItemId === \"insert-prompt\" && tab?.id) {\r\n    const lastUsedId = await getMeta<string>(\"lastUsedPromptId\");\r\n    if (lastUsedId) {\r\n      const prompt = await getPrompt(lastUsedId);\r\n      if (prompt) {\r\n        await insertIntoTab(tab.id, prompt.body);\r\n      }\r\n    }\r\n  }\r\n});\r\n\r\n// Message channel from side panel or options\r\nchrome.runtime.onMessage.addListener((msg, _sender, send) => {\r\n  (async () => {\r\n    if (msg.type === \"insert\") {\r\n      const [tab] = await chrome.tabs.query({ active: true, lastFocusedWindow: true });\r\n      if (tab?.id) {\r\n        await insertIntoTab(tab.id, msg.text as string);\r\n        send({ ok: true });\r\n      }\r\n    } else if (msg.type === \"seed:ensure\") {\r\n      await ensureSeedLoaded();\r\n      send({ ok: true });\r\n    } else if (msg.type === \"seed:reload\") {\r\n      // Force reload seeds by clearing the seed flag\r\n      await putMeta(\"seedLoaded\", false);\r\n      await putMeta(\"seedSchemaVersion\", \"\");\r\n      await ensureSeedLoaded();\r\n      send({ ok: true });\r\n    }\r\n  })();\r\n  return true;\r\n});\r\n\r\n// Load seed prompts from packaged file on first run\r\nasync function ensureSeedLoaded() {\r\n  try {\r\n    const seeded = await getMeta<boolean>(\"seedLoaded\");\r\n    const currentSchemaVersion = await getMeta<string>(\"seedSchemaVersion\");\r\n    \r\n    // Get seed data first\r\n    const url = chrome.runtime.getURL(\"data/seed.json\");\r\n    const res = await fetch(url);\r\n    if (!res.ok) throw new Error(\"Failed to load seed.json\");\r\n    const json = await res.json() as { schemaVersion: string; prompts: Prompt[] };\r\n    \r\n    // Check if we need to reload seeds (new version or never loaded)\r\n    if (seeded && currentSchemaVersion === json.schemaVersion) {\r\n      return;\r\n    }\r\n    const db = await openDb();\r\n    const tx = db.transaction(\"prompts\", \"readwrite\");\r\n    const store = tx.objectStore(\"prompts\");\r\n\r\n    await new Promise<void>((resolve, reject) => {\r\n      const now = new Date().toISOString();\r\n      for (const p of json.prompts) {\r\n        const seed: Prompt = {\r\n          ...p,\r\n          source: \"seed\",\r\n          favorite: p.favorite ?? false,\r\n          hidden: p.hidden ?? false,\r\n          createdAt: p.createdAt ?? now,\r\n          updatedAt: p.updatedAt ?? now,\r\n          version: p.version ?? 1\r\n        };\r\n        store.put(seed);\r\n      }\r\n      tx.oncomplete = () => resolve();\r\n      tx.onerror = () => reject(tx.error);\r\n      tx.onabort = () => reject(tx.error);\r\n    });\r\n\r\n    await putMeta(\"seedLoaded\", true);\r\n    await putMeta(\"seedSchemaVersion\", json.schemaVersion);\r\n  } catch (e) {\r\n    // Non-fatal, extension still works without seeds.\r\n    console.error(\"Seed load error:\", e);\r\n  }\r\n}\r\n\r\n// Remove items in recycle bin older than 30 days\r\nasync function purgeRecycleBin() {\r\n  try {\r\n    const db = await openDb();\r\n    const t = db.transaction(\"prompts\", \"readwrite\");\r\n    const store = t.objectStore(\"prompts\");\r\n    const req = store.openCursor();\r\n    const now = Date.now();\r\n    const cutoff = now - (30 * 24 * 60 * 60 * 1000); // 30 days\r\n\r\n    await new Promise<void>((resolve, reject) => {\r\n      req.onsuccess = () => {\r\n        const cur = req.result as IDBCursorWithValue | null;\r\n        if (!cur) return resolve();\r\n        const p = cur.value as Prompt;\r\n        if (p.deletedAt && new Date(p.deletedAt).getTime() < cutoff) {\r\n          store.delete(p.id);\r\n        }\r\n        cur.continue();\r\n      };\r\n      req.onerror = () => reject(req.error);\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Purge error:\", error);\r\n  }\r\n}\r\n\r\n// Try to insert text into the focused element in the tab\r\nasync function insertIntoTab(tabId: number, text: string) {\r\n  try {\r\n    await chrome.scripting.executeScript({\r\n      target: { tabId },\r\n      func: (t: string) => {\r\n        const ok = tryInsert(document.activeElement as HTMLElement | null, t) || tryFrames(t);\r\n        if (!ok) {\r\n          // Clipboard fallback\r\n          void navigator.clipboard.writeText(t);\r\n        }\r\n\r\n        function tryInsert(node: HTMLElement | null, val: string): boolean {\r\n          if (!node) return false;\r\n          \r\n          // Inputs and textareas\r\n          if ((node as HTMLInputElement).value !== undefined) {\r\n            const input = node as HTMLInputElement;\r\n            const start = input.selectionStart ?? input.value.length;\r\n            const end = input.selectionEnd ?? input.value.length;\r\n            input.setRangeText(val, start, end, \"end\");\r\n            input.dispatchEvent(new Event(\"input\", { bubbles: true }));\r\n            return true;\r\n          }\r\n          \r\n          // Contenteditable\r\n          if (node.isContentEditable) {\r\n            const sel = window.getSelection();\r\n            if (!sel) return false;\r\n            sel.deleteFromDocument();\r\n            const textNode = document.createTextNode(val);\r\n            if (sel.rangeCount === 0) {\r\n              const r = document.createRange();\r\n              r.selectNodeContents(node);\r\n              sel.addRange(r);\r\n            }\r\n            const range = sel.getRangeAt(0);\r\n            range.insertNode(textNode);\r\n            range.setStartAfter(textNode);\r\n            range.setEndAfter(textNode);\r\n            sel.removeAllRanges();\r\n            sel.addRange(range);\r\n            return true;\r\n          }\r\n          \r\n          return false;\r\n        }\r\n\r\n        function tryFrames(val: string): boolean {\r\n          for (const f of Array.from(window.frames)) {\r\n            try {\r\n              const d = f.document;\r\n              const el = d.activeElement as HTMLElement | null;\r\n              if (el && tryInsert(el, val)) {\r\n                return true;\r\n              }\r\n            } catch {\r\n              // Cross-origin frame, skip\r\n            }\r\n          }\r\n          return false;\r\n        }\r\n      },\r\n      args: [text]\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Insert failed:\", error);\r\n    // Fallback to clipboard\r\n    try {\r\n      await navigator.clipboard.writeText(text);\r\n    } catch (clipboardError) {\r\n      console.error(\"Clipboard fallback failed:\", clipboardError);\r\n    }\r\n  }\r\n}\r\n\r\n// Helper function to get prompt from database\r\nasync function getPrompt(id: string): Promise<Prompt | undefined> {\r\n  try {\r\n    const db = await openDb();\r\n    const tx = db.transaction(\"prompts\", \"readonly\");\r\n    const store = tx.objectStore(\"prompts\");\r\n    return await new Promise<Prompt | undefined>((resolve, reject) => {\r\n      const req = store.get(id);\r\n      req.onsuccess = () => resolve(req.result);\r\n      req.onerror = () => reject(req.error);\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Failed to get prompt:\", error);\r\n    return undefined;\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["tx"]
}
