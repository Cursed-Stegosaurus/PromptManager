{
  "version": 3,
  "sources": ["../src/lib/db.ts", "../src/lib/migration.ts", "../src/background/background.ts"],
  "sourcesContent": ["import type { LibraryState, Prompt } from \"./schema\";\r\n\r\nconst DB_NAME = \"prompt-library\";\r\nconst DB_VERSION = 2; // Bumped to force schema upgrade\r\nconst STORE = \"prompts\";\r\nconst META = \"meta\";\r\n\r\nexport interface Meta {\r\n  key: string;\r\n  value: any;\r\n}\r\n\r\nexport async function openDb(): Promise<IDBDatabase> {\r\n  return await new Promise((resolve, reject) => {\r\n    const req = indexedDB.open(DB_NAME, DB_VERSION);\r\n    \r\n    req.onupgradeneeded = (event) => {\r\n      console.log('Database upgrade needed, creating schema...');\r\n      const db = req.result;\r\n      \r\n      // Create prompts store if it doesn't exist\r\n      if (!db.objectStoreNames.contains(STORE)) {\r\n        console.log('Creating prompts store...');\r\n        const s = db.createObjectStore(STORE, { keyPath: \"id\" });\r\n        \r\n        // Create indexes\r\n        console.log('Creating database indexes...');\r\n        try {\r\n          s.createIndex(\"by_deletedAt\", \"deletedAt\", { unique: false });\r\n          s.createIndex(\"by_hidden\", \"hidden\", { unique: false });\r\n          s.createIndex(\"by_favorite\", \"favorite\", { unique: false });\r\n          s.createIndex(\"by_source\", \"source\", { unique: false });\r\n          console.log('All indexes created successfully');\r\n        } catch (indexError) {\r\n          console.error('Error creating indexes:', indexError);\r\n          // Continue anyway - indexes are optional\r\n        }\r\n      }\r\n      \r\n      // Create meta store if it doesn't exist\r\n      if (!db.objectStoreNames.contains(META)) {\r\n        console.log('Creating meta store...');\r\n        db.createObjectStore(META, { keyPath: \"key\" });\r\n      }\r\n    };\r\n    \r\n    req.onsuccess = () => {\r\n      console.log('Database opened successfully');\r\n      resolve(req.result);\r\n    };\r\n    \r\n    req.onerror = () => {\r\n      console.error('Database open error:', req.error);\r\n      reject(req.error);\r\n    };\r\n  });\r\n}\r\n\r\nexport async function putPrompt(p: Prompt) {\r\n  const db = await openDb();\r\n  await tx(db, STORE, \"readwrite\", store => store.put(p));\r\n}\r\n\r\n// Raw database functions (without migration)\r\nasync function getPromptRaw(id: string): Promise<Prompt | undefined> {\r\n  try {\r\n    console.log('getPromptRaw: Getting prompt with ID:', id);\r\n    const db = await openDb();\r\n    const result = await tx<Prompt | undefined>(db, STORE, \"readonly\", store => reqPromise<Prompt | undefined>(store.get(id)));\r\n    console.log('getPromptRaw: Result:', result);\r\n    return result;\r\n  } catch (error) {\r\n    console.error('getPromptRaw: Error:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nasync function listPromptsRaw(includeDeleted = false): Promise<Prompt[]> {\r\n  try {\r\n    console.log('listPromptsRaw: Starting with includeDeleted =', includeDeleted);\r\n    const db = await openDb();\r\n    console.log('listPromptsRaw: Database opened successfully');\r\n    \r\n    const result = await tx<Prompt[]>(db, STORE, \"readonly\", store => new Promise<Prompt[]>((resolve, reject) => {\r\n      const out: Prompt[] = [];\r\n      const req = store.openCursor();\r\n      req.onsuccess = () => {\r\n        const cur = req.result as IDBCursorWithValue | null;\r\n        if (!cur) {\r\n          console.log('listPromptsRaw: Cursor completed, total prompts found:', out.length);\r\n          return resolve(out);\r\n        }\r\n        const val = cur.value as Prompt;\r\n        if (!val.deletedAt || includeDeleted) out.push(val);\r\n        cur.continue();\r\n      };\r\n      req.onerror = () => reject(req.error);\r\n    }));\r\n    \r\n    console.log('listPromptsRaw: Final result:', result.length, result);\r\n    \r\n    // Get usage analytics for sorting\r\n    const { topUsedPrompts } = await getAnalytics();\r\n    \r\n    // Sort prompts: first by usage count (descending), then alphabetically by title\r\n    const sortedResult = result.sort((a, b) => {\r\n      // Get usage count for each prompt\r\n      const aUsage = topUsedPrompts.find((p: { promptId: string; usageCount: number; lastUsed: string }) => p.promptId === a.id)?.usageCount || 0;\r\n      const bUsage = topUsedPrompts.find((p: { promptId: string; usageCount: number; lastUsed: string }) => p.promptId === b.id)?.usageCount || 0;\r\n      \r\n      // First sort by usage count (descending)\r\n      if (aUsage !== bUsage) {\r\n        return bUsage - aUsage;\r\n      }\r\n      \r\n      // Then sort alphabetically by title\r\n      return a.title.localeCompare(b.title);\r\n    });\r\n    \r\n    return sortedResult;\r\n  } catch (error) {\r\n    console.error('listPromptsRaw: Error:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Enhanced getPrompt with auto-migration\r\nexport async function getPrompt(id: string): Promise<Prompt | null> {\r\n  try {\r\n    const prompt = await getPromptRaw(id);\r\n    if (prompt && (prompt.source as any) === 'seed') {\r\n      // Auto-migrate legacy data\r\n      console.log(`Auto-migrating prompt ${id} from 'seed' to 'starter'`);\r\n      (prompt as any).source = 'starter';\r\n      await putPrompt(prompt); // Save migrated version\r\n    }\r\n    return prompt || null;\r\n  } catch (error) {\r\n    console.error('Failed to get prompt:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n// Enhanced listPrompts with auto-migration\r\nexport async function listPrompts(includeDeleted = false): Promise<Prompt[]> {\r\n  try {\r\n    console.log('listPrompts: Starting with includeDeleted =', includeDeleted);\r\n    const prompts = await listPromptsRaw(includeDeleted);\r\n    console.log('listPrompts: Raw prompts from DB:', prompts.length, prompts);\r\n    \r\n    // Check if any prompts need migration\r\n    let needsMigration = false;\r\n    const migratedPrompts = prompts.map(prompt => {\r\n      if ((prompt.source as any) === 'seed') {\r\n        needsMigration = true;\r\n        return { ...prompt, source: 'starter' as const };\r\n      }\r\n      return prompt;\r\n    });\r\n    \r\n    console.log('listPrompts: Migration needed?', needsMigration);\r\n    console.log('listPrompts: Migrated prompts:', migratedPrompts.length, migratedPrompts);\r\n    \r\n    // Save migrated prompts if needed\r\n    if (needsMigration) {\r\n      console.log(`Auto-migrating ${migratedPrompts.filter(p => (p.source as any) === 'seed').length} prompts`);\r\n      await Promise.all(migratedPrompts.map(p => putPrompt(p)));\r\n      \r\n      // Mark migration as completed\r\n      await putMeta('migrationCompleted', true);\r\n      await putMeta('migrationTimestamp', new Date().toISOString());\r\n      await putMeta('migrationVersion', '2.0.0');\r\n      \r\n      console.log('Auto-migration completed and marked as complete');\r\n    }\r\n    \r\n    // Get usage analytics for sorting\r\n    const { topUsedPrompts } = await getAnalytics();\r\n    \r\n    // Sort prompts: first by usage count (descending), then alphabetically by title\r\n    const sortedPrompts = migratedPrompts.sort((a, b) => {\r\n      // Get usage count for each prompt\r\n      const aUsage = topUsedPrompts.find((p: { promptId: string; usageCount: number; lastUsed: string }) => p.promptId === a.id)?.usageCount || 0;\r\n      const bUsage = topUsedPrompts.find((p: { promptId: string; usageCount: number; lastUsed: string }) => p.promptId === b.id)?.usageCount || 0;\r\n      \r\n      // First sort by usage count (descending)\r\n      if (aUsage !== bUsage) {\r\n        return bUsage - aUsage;\r\n      }\r\n      \r\n      // Then sort alphabetically by title\r\n      return a.title.localeCompare(b.title);\r\n    });\r\n    \r\n    return sortedPrompts;\r\n  } catch (error) {\r\n    console.error('Failed to list prompts:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\nexport async function putMeta(key: string, value: any) {\r\n  const db = await openDb();\r\n  await tx(db, META, \"readwrite\", store => store.put({ key, value }));\r\n}\r\n\r\nexport async function getMeta<T>(key: string): Promise<T | undefined> {\r\n  const db = await openDb();\r\n  return await tx(db, META, \"readonly\", store => {\r\n    const req = store.get(key);\r\n    return reqPromise<{ key: string; value: T } | undefined>(req).then(r => r?.value);\r\n  });\r\n}\r\n\r\nexport async function deletePrompt(id: string) {\r\n  const db = await openDb();\r\n  const prompt = await getPrompt(id);\r\n  if (prompt) {\r\n    prompt.deletedAt = new Date().toISOString();\r\n    prompt.updatedAt = new Date().toISOString();\r\n    // Clear favorite flag when deleting\r\n    prompt.favorite = false;\r\n    await putPrompt(prompt);\r\n  }\r\n}\r\n\r\nexport async function restorePrompt(id: string) {\r\n  const db = await openDb();\r\n  const prompt = await getPrompt(id);\r\n  if (prompt && prompt.deletedAt) {\r\n    prompt.deletedAt = undefined;\r\n    prompt.updatedAt = new Date().toISOString();\r\n    await putPrompt(prompt);\r\n  }\r\n}\r\n\r\nexport async function toggleFavorite(id: string) {\r\n  const db = await openDb();\r\n  const prompt = await getPrompt(id);\r\n  if (prompt) {\r\n    prompt.favorite = !prompt.favorite;\r\n    prompt.updatedAt = new Date().toISOString();\r\n    await putPrompt(prompt);\r\n  }\r\n}\r\n\r\nexport async function toggleHidden(id: string) {\r\n  const db = await openDb();\r\n  const prompt = await getPrompt(id);\r\n  if (prompt) {\r\n    prompt.hidden = !prompt.hidden;\r\n    prompt.updatedAt = new Date().toISOString();\r\n    // Clear favorite flag when hiding (but not when unhiding)\r\n    if (prompt.hidden) {\r\n      prompt.favorite = false;\r\n    }\r\n    await putPrompt(prompt);\r\n  }\r\n}\r\n\r\nexport async function permanentlyDeletePrompt(id: string) {\r\n  const db = await openDb();\r\n  return await tx(db, STORE, \"readwrite\", store => {\r\n    return reqPromise(store.delete(id));\r\n  });\r\n}\r\n\r\nexport async function purgeDeletedPrompts(olderThanDays: number = 30) {\r\n  const db = await openDb();\r\n  const cutoff = new Date();\r\n  cutoff.setDate(cutoff.getDate() - olderThanDays);\r\n  \r\n  return await tx(db, STORE, \"readwrite\", store => new Promise((resolve, reject) => {\r\n    const req = store.openCursor();\r\n    const deletedIds: string[] = [];\r\n    \r\n    req.onsuccess = () => {\r\n      const cur = req.result as IDBCursorWithValue | null;\r\n      if (!cur) return resolve(deletedIds);\r\n      \r\n      const prompt = cur.value as Prompt;\r\n      if (prompt.deletedAt && new Date(prompt.deletedAt) < cutoff) {\r\n        deletedIds.push(prompt.id);\r\n        store.delete(prompt.id);\r\n      }\r\n      cur.continue();\r\n    };\r\n    req.onerror = () => reject(req.error);\r\n  }));\r\n}\r\n\r\n// Analytics functions\r\nexport async function incrementPromptUsage(promptId: string) {\r\n  try {\r\n    // Get current analytics data\r\n    const totalUsed = await getMeta<number>('totalPromptsUsed') ?? 0;\r\n    const topUsed = await getMeta<Array<{ promptId: string; usageCount: number; lastUsed: string }>>('topUsedPrompts') ?? [];\r\n    \r\n    // Increment total counter\r\n    await putMeta('totalPromptsUsed', totalUsed + 1);\r\n    \r\n    // Update individual prompt usage\r\n    const now = new Date().toISOString();\r\n    const existingIndex = topUsed.findIndex(p => p.promptId === promptId);\r\n    \r\n    if (existingIndex >= 0) {\r\n      // Update existing entry\r\n      topUsed[existingIndex].usageCount += 1;\r\n      topUsed[existingIndex].lastUsed = now;\r\n    } else {\r\n      // Add new entry\r\n      topUsed.push({ promptId, usageCount: 1, lastUsed: now });\r\n    }\r\n    \r\n    // Sort by usage count (highest first) and keep top 5\r\n    topUsed.sort((a, b) => b.usageCount - a.usageCount);\r\n    const top5 = topUsed.slice(0, 5);\r\n    \r\n    // Save updated top 5\r\n    await putMeta('topUsedPrompts', top5);\r\n    \r\n    return { totalUsed: totalUsed + 1, topUsed: top5 };\r\n  } catch (error) {\r\n    console.error('Failed to increment prompt usage:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\nexport async function getAnalytics() {\r\n  try {\r\n    const totalUsed = await getMeta<number>('totalPromptsUsed') ?? 0;\r\n    const topUsed = await getMeta<Array<{ promptId: string; usageCount: number; lastUsed: string }>>('topUsedPrompts') ?? [];\r\n    \r\n    return {\r\n      totalPromptsUsed: totalUsed,\r\n      topUsedPrompts: topUsed\r\n    };\r\n  } catch (error) {\r\n    console.error('Failed to get analytics:', error);\r\n    return {\r\n      totalPromptsUsed: 0,\r\n      topUsedPrompts: []\r\n    };\r\n  }\r\n}\r\n\r\nfunction tx<T>(db: IDBDatabase, name: string, mode: IDBTransactionMode, fn: (store: IDBObjectStore) => any): Promise<T> {\r\n  return new Promise((resolve, reject) => {\r\n    const t = db.transaction(name, mode);\r\n    const store = t.objectStore(name);\r\n    let result: any;\r\n    try { result = fn(store); } catch (e) { reject(e); return; }\r\n    t.oncomplete = () => resolve(result);\r\n    t.onerror = () => reject(t.error);\r\n    t.onabort = () => reject(t.error);\r\n  });\r\n}\r\n\r\nfunction reqPromise<T>(req: IDBRequest): Promise<T> {\r\n  return new Promise((resolve, reject) => {\r\n    req.onsuccess = () => resolve(req.result as T);\r\n    req.onerror = () => reject(req.error);\r\n  });\r\n}\r\n", "export interface MigrationState {\r\n  version: string;\r\n  timestamp: string;\r\n  status: 'pending' | 'in-progress' | 'completed' | 'failed';\r\n  rollbackVersion?: string;\r\n  dataBackup?: string;\r\n}\r\n\r\nexport interface MigrationResult {\r\n  success: boolean;\r\n  migratedCount: number;\r\n  errors: string[];\r\n  backupCreated: boolean;\r\n}\r\n\r\nexport class MigrationManager {\r\n  private static instance: MigrationManager;\r\n  \r\n  static getInstance(): MigrationManager {\r\n    if (!MigrationManager.instance) {\r\n      MigrationManager.instance = new MigrationManager();\r\n    }\r\n    return MigrationManager.instance;\r\n  }\r\n  \r\n  async migrateSeedToStarter(): Promise<MigrationResult> {\r\n    const result: MigrationResult = {\r\n      success: false,\r\n      migratedCount: 0,\r\n      errors: [],\r\n      backupCreated: false\r\n    };\r\n    \r\n    try {\r\n      console.log('Starting migration from seed to starter...');\r\n      \r\n      // 1. Create backup\r\n      result.backupCreated = await this.createBackup();\r\n      if (!result.backupCreated) {\r\n        throw new Error('Failed to create backup');\r\n      }\r\n      \r\n      // 2. Update existing data\r\n      result.migratedCount = await this.updateExistingData();\r\n      \r\n      // 3. Update schema and metadata\r\n      await this.updateSchema();\r\n      \r\n      // 4. Validate migration\r\n      await this.validateMigration();\r\n      \r\n      result.success = true;\r\n      console.log(`Migration completed successfully. Migrated ${result.migratedCount} prompts.`);\r\n      \r\n    } catch (error) {\r\n      result.errors.push(error instanceof Error ? error.message : 'Unknown error');\r\n      console.error('Migration failed:', error);\r\n      \r\n      // Attempt rollback\r\n      try {\r\n        await this.rollback();\r\n        console.log('Rollback completed successfully');\r\n      } catch (rollbackError) {\r\n        result.errors.push(`Rollback failed: ${rollbackError instanceof Error ? rollbackError.message : 'Unknown error'}`);\r\n        console.error('Rollback failed:', rollbackError);\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n  \r\n  private async createBackup(): Promise<boolean> {\r\n    try {\r\n      const { openDb, listPrompts } = await import('./db.js');\r\n      const db = await openDb();\r\n      const prompts = await listPrompts(true);\r\n      \r\n      const backup = {\r\n        timestamp: new Date().toISOString(),\r\n        version: '1.0.0',\r\n        prompts: prompts\r\n      };\r\n      \r\n      // Store backup in metadata\r\n      const { putMeta } = await import('./db.js');\r\n      await putMeta('migrationBackup', backup);\r\n      \r\n      console.log(`Backup created with ${prompts.length} prompts`);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('Failed to create backup:', error);\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  private async updateExistingData(): Promise<number> {\r\n    try {\r\n      const { openDb, listPrompts, putPrompt } = await import('./db.js');\r\n      const db = await openDb();\r\n      const prompts = await listPrompts(true);\r\n      \r\n      let migratedCount = 0;\r\n      \r\n      for (const prompt of prompts) {\r\n        if (prompt.source === 'seed') {\r\n          const updatedPrompt = { ...prompt, source: 'starter' as const };\r\n          await putPrompt(updatedPrompt);\r\n          migratedCount++;\r\n        }\r\n      }\r\n      \r\n      console.log(`Updated ${migratedCount} prompts from seed to starter`);\r\n      return migratedCount;\r\n    } catch (error) {\r\n      console.error('Failed to update existing data:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  private async updateSchema(): Promise<void> {\r\n    try {\r\n      const { putMeta } = await import('./db.js');\r\n      \r\n      // Update migration state\r\n      await putMeta('migrationCompleted', true);\r\n      await putMeta('migrationTimestamp', new Date().toISOString());\r\n      await putMeta('migrationVersion', '2.0.0');\r\n      \r\n      console.log('Schema updated successfully');\r\n    } catch (error) {\r\n      console.error('Failed to update schema:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  private async validateMigration(): Promise<void> {\r\n    try {\r\n      const { listPrompts } = await import('./db.js');\r\n      const prompts = await listPrompts(true);\r\n      \r\n      // Check that no prompts still have 'seed' source\r\n      const remainingSeedPrompts = prompts.filter(p => p.source === 'seed');\r\n      if (remainingSeedPrompts.length > 0) {\r\n        throw new Error(`Migration validation failed: ${remainingSeedPrompts.length} prompts still have 'seed' source`);\r\n      }\r\n      \r\n      console.log('Migration validation passed');\r\n    } catch (error) {\r\n      console.error('Migration validation failed:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  private async rollback(): Promise<void> {\r\n    try {\r\n      const { putMeta, getMeta } = await import('./db.js');\r\n      \r\n      // Get backup\r\n      const backup = await getMeta('migrationBackup');\r\n      if (!backup) {\r\n        throw new Error('No backup found for rollback');\r\n      }\r\n      \r\n      // Restore prompts from backup\r\n      const { putPrompt } = await import('./db.js');\r\n      for (const prompt of backup.prompts) {\r\n        await putPrompt(prompt);\r\n      }\r\n      \r\n      // Reset migration state\r\n      await putMeta('migrationCompleted', false);\r\n      await putMeta('migrationTimestamp', '');\r\n      await putMeta('migrationVersion', '');\r\n      \r\n      console.log('Rollback completed successfully');\r\n    } catch (error) {\r\n      console.error('Rollback failed:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  async checkMigrationStatus(): Promise<MigrationState> {\r\n    try {\r\n      const { getMeta } = await import('./db.js');\r\n      \r\n      const completed = await getMeta<boolean>('migrationCompleted');\r\n      const timestamp = await getMeta<string>('migrationTimestamp');\r\n      const version = await getMeta<string>('migrationVersion');\r\n      \r\n      return {\r\n        version: version || '1.0.0',\r\n        timestamp: timestamp || '',\r\n        status: completed ? 'completed' : 'pending'\r\n      };\r\n    } catch (error) {\r\n      console.error('Failed to check migration status:', error);\r\n      return {\r\n        version: '1.0.0',\r\n        timestamp: '',\r\n        status: 'failed'\r\n      };\r\n    }\r\n  }\r\n}\r\n", "import { openDb, putPrompt, getMeta, putMeta, incrementPromptUsage } from '../lib/db.js';\r\nimport type { Prompt } from '../lib/schema.js';\r\n\r\n// Daily purge of recycle bin (placeholder for future implementation)\r\nif (chrome.alarms) {\r\n  chrome.alarms.onAlarm.addListener(async (alarm) => {\r\n    if (alarm.name === \"purge-recycle-bin\") {\r\n      try {\r\n        // TODO: Implement purgeRecycleBin function\r\n        console.log(\"Recycle bin purge requested (not yet implemented)\");\r\n      } catch (error) {\r\n        console.error(\"Failed to purge recycle bin:\", error);\r\n      }\r\n    }\r\n  });\r\n} else {\r\n  console.log(\"Chrome alarms API not available - recycle bin auto-purge disabled\");\r\n}\r\n\r\n// Handle extension icon click to open sidebar\r\nif (chrome.action && chrome.action.onClicked) {\r\n  chrome.action.onClicked.addListener(async (tab) => {\r\n    try {\r\n      console.log('Extension icon clicked, opening sidebar...');\r\n      if (chrome.sidePanel && chrome.sidePanel.open) {\r\n        await chrome.sidePanel.open({ windowId: tab.windowId });\r\n        console.log('Sidebar opened successfully');\r\n      } else {\r\n        console.log('SidePanel API not available');\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to open sidebar:', error);\r\n    }\r\n  });\r\n} else {\r\n  console.log(\"Chrome action API not available - extension icon click disabled\");\r\n}\r\n\r\n// Ensure starters are loaded when extension starts\r\nif (chrome.runtime && chrome.runtime.onStartup) {\r\n  chrome.runtime.onStartup.addListener(async () => {\r\n    try {\r\n      await ensureStarterLoaded();\r\n    } catch (error) {\r\n      console.error(\"Failed to ensure starters loaded on startup:\", error);\r\n    }\r\n  });\r\n} else {\r\n  console.log(\"Chrome runtime startup API not available\");\r\n}\r\n\r\nif (chrome.runtime && chrome.runtime.onInstalled) {\r\n  chrome.runtime.onInstalled.addListener(async (details) => {\r\n    try {\r\n      if (details.reason === 'install') {\r\n        // Fresh installation - just load starters\r\n        await ensureStarterLoaded();\r\n      } else if (details.reason === 'update') {\r\n        // Extension update - check if migration is needed\r\n        console.log('Extension updated, checking for migration needs...');\r\n        const needsMigration = await checkIfMigrationNeeded();\r\n        if (needsMigration) {\r\n          console.log('Migration needed after update, executing...');\r\n          const { MigrationManager } = await import('../lib/migration.js');\r\n          const migrationManager = MigrationManager.getInstance();\r\n          const result = await migrationManager.migrateSeedToStarter();\r\n          \r\n          if (result.success) {\r\n            console.log(`Migration completed successfully after update. Migrated ${result.migratedCount} prompts.`);\r\n          } else {\r\n            console.error('Migration failed after update:', result.errors);\r\n          }\r\n        }\r\n        await ensureStarterLoaded();\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Failed to handle extension installation/update:\", error);\r\n    }\r\n  });\r\n} else {\r\n  console.log(\"Chrome runtime installed API not available\");\r\n}\r\n\r\n// Handle messages from content scripts and sidepanel\r\nif (chrome.runtime && chrome.runtime.onMessage) {\r\n  chrome.runtime.onMessage.addListener(async (msg, sender, sendResponse) => {\r\n    console.log('Background: Received message:', msg.type, 'from:', sender);\r\n    try {\r\n      if (msg.type === \"insert\") {\r\n        const tabId = sender.tab?.id;\r\n        if (tabId && chrome.scripting) {\r\n          await insertIntoTab(tabId, msg.text);\r\n          sendResponse({ success: true });\r\n        } else {\r\n          sendResponse({ success: false, error: \"Scripting API not available\" });\r\n        }\r\n      } else if (msg.type === \"starter:ensure\") {\r\n        console.log('Background: Processing starter:ensure message...');\r\n        await ensureStarterLoaded();\r\n        console.log('Background: starter:ensure completed');\r\n        sendResponse({ success: true });\r\n      } else if (msg.type === \"starter:reload\") {\r\n        // Force reload starters by clearing the starter flag\r\n        await putMeta(\"starterLoaded\", false);\r\n        await putMeta(\"starterSchemaVersion\", \"\");\r\n        await ensureStarterLoaded();\r\n        sendResponse({ success: true });\r\n      } else if (msg.type === \"incrementUsage\") {\r\n        await incrementPromptUsage(msg.promptId);\r\n        sendResponse({ success: true });\r\n      } else if (msg.type === \"migration:status\") {\r\n        const { MigrationManager } = await import('../lib/migration.js');\r\n        const migrationManager = MigrationManager.getInstance();\r\n        const status = await migrationManager.checkMigrationStatus();\r\n        sendResponse({ success: true, status });\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Message handling error:\", error);\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      sendResponse({ success: false, error: errorMessage });\r\n    }\r\n    return true; // Keep message channel open for async response\r\n  });\r\n} else {\r\n  console.log(\"Chrome runtime message API not available\");\r\n}\r\n\r\n// Insert text into a tab\r\nasync function insertIntoTab(tabId: number, text: string) {\r\n  try {\r\n    if (!chrome.scripting) {\r\n      throw new Error(\"Chrome scripting API not available\");\r\n    }\r\n    \r\n    await chrome.scripting.executeScript({\r\n      target: { tabId },\r\n      func: (textToInsert) => {\r\n        const activeElement = document.activeElement as HTMLInputElement | HTMLTextAreaElement | null;\r\n        if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {\r\n          const start = activeElement.selectionStart || 0;\r\n          const end = activeElement.selectionEnd || 0;\r\n          const value = activeElement.value;\r\n          activeElement.value = value.substring(0, start) + textToInsert + value.substring(end);\r\n          activeElement.setSelectionRange(start + textToInsert.length, start + textToInsert.length);\r\n          activeElement.focus();\r\n        }\r\n      },\r\n      args: [text]\r\n    });\r\n  } catch (error) {\r\n    console.error(\"Failed to insert text into tab:\", error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n// Load starter prompts from packaged file on first run\r\nasync function ensureStarterLoaded() {\r\n  try {\r\n    console.log('ensureStarterLoaded: Starting...');\r\n    \r\n    // Check if migration is needed first\r\n    const needsMigration = await checkIfMigrationNeeded();\r\n    console.log('ensureStarterLoaded: Migration needed?', needsMigration);\r\n    \r\n    if (needsMigration) {\r\n      console.log('Migration needed, executing...');\r\n      const { MigrationManager } = await import('../lib/migration.js');\r\n      const migrationManager = MigrationManager.getInstance();\r\n      const result = await migrationManager.migrateSeedToStarter();\r\n      \r\n      if (result.success) {\r\n        console.log(`Migration completed successfully. Migrated ${result.migratedCount} prompts.`);\r\n      } else {\r\n        console.error('Migration failed:', result.errors);\r\n      }\r\n    }\r\n    \r\n    const seeded = await getMeta<boolean>(\"starterLoaded\");\r\n    const currentSchemaVersion = await getMeta<string>(\"starterSchemaVersion\");\r\n    console.log('ensureStarterLoaded: Current state - seeded:', seeded, 'version:', currentSchemaVersion);\r\n    \r\n    // Get starter data first\r\n    const url = chrome.runtime.getURL(\"data/starter.json\");\r\n    console.log('ensureStarterLoaded: Loading from URL:', url);\r\n    const res = await fetch(url);\r\n    if (!res.ok) throw new Error(\"Failed to load starter.json\");\r\n    const json = await res.json();\r\n    console.log('ensureStarterLoaded: Loaded starter.json with', json.prompts.length, 'prompts');\r\n    \r\n    // Check if we need to reload starters (new version or never loaded)\r\n    if (seeded && currentSchemaVersion === json.schemaVersion) {\r\n      console.log(\"Starters already loaded with current version\");\r\n      return;\r\n    }\r\n    \r\n    console.log(\"Loading starter prompts...\");\r\n    const db = await openDb();\r\n    const tx = db.transaction(\"prompts\", \"readwrite\");\r\n    const store = tx.objectStore(\"prompts\");\r\n    \r\n    // Clear existing starters first\r\n    let existingStarters: Prompt[] = [];\r\n    try {\r\n      // Try to use the index if it exists\r\n      if (store.indexNames.contains(\"by_source\")) {\r\n        existingStarters = await new Promise<Prompt[]>((resolve, reject) => {\r\n          const req = store.index(\"by_source\").getAll(\"starter\");\r\n          req.onsuccess = () => resolve(req.result);\r\n          req.onerror = () => reject(req.error);\r\n        });\r\n      } else {\r\n        // Fallback: scan all prompts manually\r\n        console.log('Source index not found, scanning all prompts manually...');\r\n        existingStarters = await new Promise<Prompt[]>((resolve, reject) => {\r\n          const out: Prompt[] = [];\r\n          const req = store.openCursor();\r\n          req.onsuccess = () => {\r\n            const cur = req.result as IDBCursorWithValue | null;\r\n            if (!cur) return resolve(out);\r\n            const val = cur.value as Prompt;\r\n            if (val.source === 'starter') out.push(val);\r\n            cur.continue();\r\n          };\r\n          req.onerror = () => reject(req.error);\r\n        });\r\n      }\r\n    } catch (indexError) {\r\n      console.log('Index access failed, scanning all prompts manually...');\r\n      // Fallback: scan all prompts manually\r\n      existingStarters = await new Promise<Prompt[]>((resolve, reject) => {\r\n        const out: Prompt[] = [];\r\n        const req = store.openCursor();\r\n        req.onsuccess = () => {\r\n          const cur = req.result as IDBCursorWithValue | null;\r\n          if (!cur) return resolve(out);\r\n          const val = cur.value as Prompt;\r\n          if (val.source === 'starter') out.push(val);\r\n          cur.continue();\r\n        };\r\n        req.onerror = () => reject(req.error);\r\n      });\r\n    }\r\n    \r\n    console.log('ensureStarterLoaded: Found', existingStarters.length, 'existing starters to clear');\r\n    \r\n    for (const existing of existingStarters) {\r\n      store.delete(existing.id);\r\n    }\r\n    \r\n    // Load new starters\r\n    for (const promptData of json.prompts) {\r\n      const starter: Prompt = {\r\n        ...promptData,\r\n        source: \"starter\",\r\n        createdAt: promptData.createdAt || new Date().toISOString(),\r\n        updatedAt: promptData.updatedAt || new Date().toISOString()\r\n      };\r\n      store.put(starter);\r\n    }\r\n    \r\n    await new Promise<void>((resolve, reject) => {\r\n      tx.oncomplete = () => resolve();\r\n      tx.onerror = () => reject(tx.error);\r\n    });\r\n    \r\n    await putMeta(\"starterLoaded\", true);\r\n    await putMeta(\"starterSchemaVersion\", json.schemaVersion);\r\n    console.log(`Loaded ${json.prompts.length} starter prompts successfully`);\r\n  } catch (e) {\r\n    // Non-fatal, extension still works without starters.\r\n    console.error(\"Starter load error:\", e);\r\n  }\r\n}\r\n\r\n// Check if migration from seed to starter is needed\r\nasync function checkIfMigrationNeeded(): Promise<boolean> {\r\n  try {\r\n    const migrationCompleted = await getMeta<boolean>(\"migrationCompleted\");\r\n    if (migrationCompleted) {\r\n      console.log('Migration already completed');\r\n      return false;\r\n    }\r\n    \r\n    // Check if any prompts still have 'seed' source\r\n    const { listPrompts } = await import('../lib/db.js');\r\n    const prompts = await listPrompts(true);\r\n    const hasSeedPrompts = prompts.some(p => (p.source as any) === 'seed');\r\n    \r\n    if (hasSeedPrompts) {\r\n      console.log('Found prompts with seed source, migration needed');\r\n      return true;\r\n    }\r\n    \r\n    console.log('No seed prompts found, migration not needed');\r\n    return false;\r\n  } catch (error) {\r\n    console.error('Error checking migration status:', error);\r\n    return false;\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["openDb", "listPrompts", "putMeta", "putPrompt", "getMeta", "MigrationManager", "tx", "listPrompts"]
}
